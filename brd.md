# Документ с Бизнес-Требованиями (BRD) для Визуального Редактора LTX конфигов S.T.A.L.K.E.R.: Зов Припяти

## 1. Цели и Задачи Проекта

**Цель:** Создать визуальный редактор конфигов для игры S.T.A.L.K.E.R.: Зов Припяти.

**Главная Задача:** Визуализировать, тем самым упростив, и сделать контролируемым, а также само-проверочным процесс
создания и редактирования игровых конфигов с возможностью строить дерево инфопоршней

На подумать:

1) Не забыть про DLTX
2) Не забыть про то, что инфопоршни еще лежат в xml диалогах. Там такой же подход, но еще проще, т.к. там заранее
   определены все теги
3) Можно ли подружить с каким-нибудь редактором типо Idea/VSCode чтобы можно было туда ссылаться на исходники скриптов
4) В теории еще круто делать поля-агреггаты где несколько полей настраиваются в одном интерфейсе, например, координаты
   брони в инвентаре:

```
inv_grid_width		= 2
inv_grid_height 	= 2
inv_grid_x		= 0
inv_grid_y		= 18
```

### Конкретные задачи для достижения цели:

1. Создать гибкую систему для управления типами секций и типов полей в них. Во внешнем файле будут описываться секции с
набором их полей и типов этих полей. А внутри самого редактора можно будет добавлять функционал для новых типов полей. 
2. Создать сам редактор.
3. Протестировать редактор на ЗП и уже готовых модах.

## 2. Описание Проблемы

* Сейчас не существует удобного инструмента для редактирования в котором будет вся информация про то, что как заполняется
та или иная секция.
* По самой секции нелегко догадаться какие поля за что отвечают и документация раскидана по вообще всему интернету.
* До сих пор редактора конфигов лучше Idea не придумали, а в ней нельзя реализовать систему типов полей для
создания Именно визуального редактора.
* Ну и просто смертельно надоело прыгать по конфигам через поиск, а не через шифт+ЛКМ. 

## 3. Что Входит в Проект

1. Сам редактор конфигов
2. Исходный набор типов секций и полей
3. Инструмент для добавления новых типов полей в движке

## 4. Что НЕ Входит в Проект

(Данный раздел предназначен для определения границ проекта и избежания их размывания. В предоставленных исходниках
конкретные пункты для этого раздела отсутствуют.)

## 5. Бизнес-Требования

Этот раздел описывает, что система должна позволять делать бизнесу или пользователю для достижения целей.

### 5.1. Работа с файлами

* Редактор должен работать сразу со всеми конфигами в выбранной рабочей папке
* Возможность создавать, открывать, сохранять и удалять конфиги
* Возможность сохранять изменения как отдельный мод с использованием DLTX
* Возможность обозначать конфиг как "логика". Для таких конфигов будет использоваться специальный [интерфейс](#541-визуализация-и-редактирование-logic-конфигов)

### 5.2. Работа с типами секций

* Должна быть возможность создавать новые типы секций, т.е. обозначать набор доступных, но не обязательно всех, полей в
  этой секции
* Должна быть возможность создавать тип секций "Перечисление", что идентифицирует секцию как перечисление полей, где
  каждое поле будет представлять собой отдельный элемент этого перечисления с уникальным именем, которое может быть
  секцией или просто строкой (**!!** может ли быть что-то еще? цифры? список?), и может (а может и быть пустым) иметь
  значение, состоящее из одного/нескольких полей, которым можно давать название, один из существующих тип и указывать
  разделитель между значениями

```
; amount, chance
[trade_generic_buy]
;Артефакты
af_cristall				= 1, 0.6
af_fireball				= 1, 0.6
af_dummy_glassbeads		        = 1, 0.6
drug_booster		                ;NO TRADE
```

* Должна быть возможность назначать тип секции 1) одной секции 2) нескольким секциям сразу 3) всему файлу 4) всей папке
* Должна быть возможность в самом редакторе менять типы полей у полей в секциях, чтобы можно было менять типы полей в
  уже существующих секциях
* Должна быть возможность сделать дубликат секции в этом же файле
* Должна быть возможность "скопировать" секцию в другой файл, чтобы можно было переносить секции между файлами
* Должна быть возможность добавить комментарий к полю что будет выглядеть как `a = 1;комментарий`
* Должна быть возможность добавлять поле типа комментарий, которое будет выглядеть как `;комментарий`, судя по всему это
  стандарт в перечисление, т.к. можно добавить пояснение к тем полям что ниже
* Должна быть возможность добавить комментарий к cекции что будет выглядеть как

```
;комментарий
[секция]
```

* Должна быть возможность добавлять/удалять родительскую секцию
* Должна быть возможность подсматривать в родительскую секцию
* <Поддержка DLTX>

### 5.3. Работа с полями

* Должна быть возможность создавать новые типы полей, которые будут иметь персональный интерфейс в редакторе
* Должна быть возможность добавить объяснение к полю, которое будет отображаться в редакторе
* Должен быть тип "Неизвестно", который будет использоваться для полей, которые не поддерживаются редактором, но могут
  быть в секции
* <Поддержка DLTX>
* Должна быть возможность определить, может ли этот тип поля быть списком, т.е. может ли поле принимать
  несколько значений, разделенных запятыми или специально обозначенным разделителем. 
* По умолчанию должны быть эти типы полей с уникальным интерфейсом, где + означает может ли быть списком:
    * +**Неизвестно**: Все значение поля будет принимать как одна строка - `a = literally anything`
    * +**Булево**: `af_quest_b14_twisted = true`
    * +**Файл из одной из папок из gamedata**: Поле для выбора относительного пути файла из одной из папок в gamedata с
      флагом "Без формата". **Пример**: `blood = wm\wm_blood_1` - где `wm\wm_blood_1.thm` - это относительный путь до файла
      в папке `textures` в `gamedata`
    * -**Прогрессия**: Обозначает прогрессию - `rating = novice, 300, experienced, 600, veteran, 900, master`
    * -**Нумерованный список**: Список со значениям где каждому придается порядковый номер -
      `communities		= actor, 0, bandit, 1, dolg, 2, ecolog, 3, freedom, 4, killer, 5, army, 6, monolith, 7, monster, 8, stalker, 9, zombied, 10`
    * +**Название секции**: с флагом `Локально`, что позволит выбирать только секции из этого/импортированных файлов -
      `character_profile     = sim_default_duty_1`
    * +**Значение из нумерованного списка**: Поле в котором содержится значение из нумерованного списка -
      `community = dolg`
    * +**Переводимая строка**: Айди по которому можно найти строку в переводах игры -
      `name = ui_inv_outfit_chemical_burn_protection`
    * +**Иконка**: Название иконки? - `icon     = ui_am_prop_chem`
    * +**Функтор**: Название файла и функции из него - `functor  = inventory_upgrades.property_functor_a`
    * -**Слайдер**: Выбор значения от какого-то до какого-то - `antirad					= 0.08`
    * -**Кондлист**: Ну это пиздец, вот отдельный [раздел](#54-визуализация-и-редактирование-condlists)
        * Должна быть возможность указать возвращаемый тип: bool, секция или строка (**!!!** Есть ли что-то еще?)
    * -**Список полей разного типа**: Содержит несколько полей разных типов, разделенных запятыми. Важно чтобы у каждого
      элементы была подсказка с именем и описанием

```
;----------------------------------------------------------------------------------------------------------------------------------------
;format:    time(sec),	        sound_name,	       light_R, G,   B,    light_range, particle_name,			        af_animation_name
;----------------------------------------------------------------------------------------------------------------------------------------
starting =	5.0,		anomaly\gravi_idle00,	0.5,    1.0, 1.5,  5.0,	       "anomaly2\artefact_gravi_blast_start",	"idle"
```

P.S. Там еще куча полей которым можно сделать свой интерфейс, но точно не сейчас. Например,
`full_scale_icon` в `outfit.ltx`

### 5.4. Визуализация и редактирование condlists

**Что такое Condlist?**
`Condlist` (Condition List) – это способ написания динамических конфигурационных файлов, позволяющий выполнять различные
действия или возвращать разные значения в зависимости от условий. Он состоит из блоков условий и возвращаемых значений,
а также может включать эффекты.  `Condlists` используются в игровом движке для определения логики квестов, поведения NPC
и других динамических систем.

**Примеры использования в игре:**

* `precondition`: Определяет условия для выдачи квеста NPC. Например, `precondition = {=random_chance(100)} true, false`
  или `precondition = {=is_rain} true, false` .
* `on_complete`, `on_init`, `on_fail`, `on_reversed`: Выполняют эффекты при смене статуса квеста (завершение,
  инициализация, провал, отмена). Возвращаемое значение `condlist` в этих полях игнорируется. .
* `condlist_N`: Используется для проверки статуса выполнения квеста, должен возвращать "complete", "fail" или "
  reversed" .
* `title_functor`, `descr_functor`, `target_functor`: Могут быть `condlists`, возвращающими строковые идентификаторы для
  динамического текста или целей .

**Требования к редактору condlists:**

* Система должна визуализировать сложную логику `condlists` для упрощения понимания и редактирования.
* Редактор должен поддерживать создание и модификацию блоков условий, включая:
    * **Проверку наличия (+info), отсутствия (-info) или отрицания (!info) информационных порций.**
        * Например, `+C` означает `db.actor:has_info("C")`, а `-D` означает `not db.actor:has_info("D")`.  `!info` (или
          `!B`) означает `not xr_conditions.B`.
        * При взаимодействии с элементом, представляющим информационную порцию (например, клик ПКМ), должно открываться
          контекстное меню с опциями: **"Выдается"** (`+info`), **"Забирается"** (`-info`), **"Используется"** (
          `=info`). (Например, для `+pri_a21_task_end` или `-simulation_task_52_dead_spawned` ).
    * **Вызов встроенных и пользовательских функций условий (=function_name(arg1:arg2)) из `xr_conditions.txt`.**
        * Редактор должен предоставлять удобный выбор этих функций (например, `actor_has_item`, `is_rain`,
          `squad_exist`, `is_dead` ) и их параметров (строковых аргументов `p, p, c`).
    * **Указание вероятности выполнения условия (~chance).**
        * Например, `~30` означает 70% шанс, `~80` означает 20%.
* Должна быть поддержка множественных блоков условий (`{cond1} result1, {cond2} result2, result3`), позволяющих
  реализовать логику "if-elseif-else". Редактор должен визуализировать последовательную проверку этих блоков, как это
  реализовано в игре при парсинге `condlist_N`.
* Система должна позволять добавлять и редактировать эффекты (`%=effect_name(arg1:arg2)%`) внутри `condlists`.
    * Например, `%=E(e1)` выполняет `xr_effects.E(game_object_1, game_object_2, {"e1"})`.
    * Примеры эффектов из `tm_dynamic.ltx`: `reward_stash(true)`, `inc_goodwill_by_tasker_comm(simulation_task_52:50)`,
      `remove_quest_item(simulation_task_52)` .
    * Эффекты могут быть кастомными функциями, определенными в `xr_effects`. Например, `give_tuna_to_actor`.
* **Визуализация и редактирование множественных эффектов:** Внутри одной части `condlist` (до или после возвращаемого
  значения) может быть несколько эффектов (например, `%=E(e1) +F -G%`), а также несколько информационных порций (`+F`,
  `-G`). Редактор должен визуально четко разделять и позволять легко добавлять/удалять/редактировать каждый из этих
  элементов.
* **Ожидаемые возвращаемые значения:** Редактор должен предоставлять явные указания и, по возможности, валидацию для
  ожидаемых возвращаемых значений `condlists` в различных полях.
    * `condlist_N` (статус выполнения квеста) должен возвращать "complete", "fail" или "reversed".
    * `precondition` (условие выдачи квеста) должен возвращать "true" или "false" (строками), влияя на то, будет ли NPC
      предлагать квест.
    * `title_functor`, `descr_functor`, `target_functor` (динамические текст/цель) должны возвращать строковые
      идентификаторы (текстовые ключи или имена объектов) или `nil`. Возможность возврата `nil` для `target` означает,
      что метка цели может быть временно скрыта, если условие не выполняется.
    * `on_init`, `on_complete`, `on_reversed`, `on_fail` (эффекты при смене статуса) не должны иметь возвращаемого
      значения, так как их результат игнорируется движком, и важны только побочные эффекты.
    * `reward_money` и `reward_item` должны возвращать число (для денег) или строки с именами предметов (для предметов),
      которые могут быть разделены двоеточием (например, "beer:vodka:vodka2").
* **Интеллектуальный ввод аргументов функций:** Для функций `xr_conditions` и `xr_effects` (таких как `actor_has_item`,
  `is_rain`, `squad_exist`, `is_dead`), редактор должен предлагать не просто строковый ввод, а контекстно-зависимые
  элементы управления. Например, для числовых аргументов — поля ввода чисел, для булевых — чекбоксы, для ссылок на
  объекты или фракции — выпадающие списки или средства поиска, опираясь на информацию о возможных значениях и функциях.
  Это значительно упростит работу и снизит количество ошибок.

### 5.41 Визуализация и редактирование logic конфигов
* Предоставляет визуальный интерфейс настройки полей секций в конфиге
* Визуально связывает между собой секции на основе полей с типом **Секция**Ju
![Редактор диалогов](https://media.discordapp.net/attachments/1381441097615675473/1384462136759029822/434073160-9be6acb7-7dd9-4445-93d9-215a502bdeac.png?ex=68528457&is=685132d7&hm=e7bac63c1b0ec550704f9f9f5d7e35148b3eed3eb93be0ce006f73e78429873c&=&format=webp&quality=lossless)

### 5.5 Навигация по инфопоршням

Благодаря парсингу кондлистов и xml диалогов, мы можем сделать дерево инфопоршней, по которому можно будет иерархически
связать между собой скрипты-конфиги, поведение нпс, диалоги и все остальный файлы этой мега-системы.
По нажатию по инфопоршню, должно открываться дерево инфопоршней где можно увидеть от каких поршней зависит данный
инфопоршень, а также какие поршни зависят от него. Тут же будет возможность увидеть/построить полное дерево инфопоршней
всей игры.

**!!!** Вопрос, что делать со скриптами, т.к. много скриптов где выдаются/проверяются инфопоршни. Типо
`dialogs_jupiter.actor_relocate_evacuation_info`

### 5.6. Навигация по секциям

По аналогии с VS можно нажать на секцию и найти где другие секции на нее ссылаются

### 5.7. Контроль и самопроверка

* Редактор должен включать механизмы для контроля корректности создаваемой логики (например, проверка синтаксиса
  `condlists` и правильности ссылок на информационные порции или функции Lua).
* Проверка что все используемые секции где-то созданы
* Для всех типов полей должен быть валидатор, который проверяет корректность введенных данных, а это значит можно
  "компилировать" текущую геймдату и проверять ее на ошибки

### 5.8. Производительность и удобство использования

* Интерфейс редактора должен быть интуитивно понятным и эффективным, позволяющим быстро создавать и редактировать
  квесты, чтобы уложиться в сроки работы над квестовыми линиями для "Сталкер: Гамма".

### 5.9. Взаимодействие с другими редакторами

* IconEditor
    * Осведомляет\генерирует для TaskEditor иконки, которые могут быть использованы в типовых полях